# 算法练习


### 字符串

页码 | 题目 |  实现思路
------|-------|-----
51    | 5.替换空格    | Done
124   | 19.正则表达式匹配  | Done
127   |  20.表示数字的字符串   | Done
284   |  58.翻转单词顺序    |
286  |   58.2.左旋转字符串|
318  |  67.把字符串转换成整数 |

### 数组

页码 | 题目 |  实现思路
------|-------|-----
39    | 3.数组中重复的数    | Done
44    | 4.二维数组中的查找   | Done

### 栈和队列

页码 | 题目 |  实现思路
------|-------|-----
68    | 9.用两个栈实现队列    | Done
165   |  30.包含min函数的栈 （单调栈） | 可以借助一个辅助栈来实现：每次压入新元素到数据栈中时，同时把当前的最小元素压入辅助栈；每次从数据栈中弹出栈顶元素时，同时将辅助栈顶的最小元素弹出。这样就能保证辅助栈的栈顶一直都是最小元素。
168   |  31.栈的压入弹出序列 |
288   |  滑动窗口的最大值 |
292   |  59.2.队列的最大值 |

### 链表

页码 | 题目 |  实现思路
------|-------|-----
58    | 6.从尾到头打印链表    | Done
119   | 18.O(1)时间删除链表的节点    | Done
122   | 18-2.删除排序链表中重复的节点    | Done
134   |  22.链表中倒数第k个节点    | Done
139   |  23.链表中环的入口(双指针总结)    | Done
142   | 24.反转链表   | Done
145    | 25.合并两个排序的链表    | Done
187    | 35.复杂链表的复制   | ① 合二为一，将复制后的每一个节点 N' 作为原节点 N 的 next 节点；② 找到复制后的各节点的 sibling 节点，连接起来；③ 将合成的链表一分为二
253    | 52.两个链表的第一个公共节点 | ① 分别计算两个链表的长度，算出两者之差 gap；② 在较长的链表上先走 gap 步，然后再同步遍历两个链表，直到找到第一个公共节点

### 哈希表

页码 | 题目 |  实现思路
------|-------|-----
39    |  3.数组中重复的数   | Done

### 树

页码 | 题目 |  实现思路
------|-------|-----
60    | 总结：二叉树的遍历    | Done
62    | 7.重建二叉树    | Done
65    | 8.二叉树的下一个节点    | Done
148   |  26.树的子结构    |  ① 先中序遍历 A 树，找到与 B 树根节点相同的节点；② 中序遍历递归比对 A 树和 B 树的节点是否是父子树的关系；③ 如果不是子树，就继续遍历 A 树，找出下一个与 B 树根节点相同的节点。然后再重复第 2 步。
151   |  27.二叉树的镜像（翻转二叉树）  | 中序遍历，交换左右子树
159   |  28.对称的二叉树    | Done
171   |  32.从上到下打印二叉树    | Done
174   |  32.2.分行从上到下打印二叉树    | Done
176   |  32.3.之字形打印二叉树   | Done
179   |  33.二叉搜索树的后序遍历   | Done
182   |  34.二叉树中和为某一值的路径    | Done
191   |  36.二叉搜索树与双向链表   | ① 指针连接：树节点中指向左节点的指针转成链表节点中指向前一个节点的指针（Node* pLeft 转成 Node* pPre），右节点同理（Node* pRight 转成 Node* pNext）； ② 排序：对二叉搜索树中序遍历出来的数值正好是递增的；③ 分解、递归：把二叉树看成 3 部分，左子树、根节点、右子树，把左、右子树都转换成排序双向链表后，再和根节点串联起来。
194   |  37.序列化二叉树   | 前序遍历进行序列化，然后再反序列化；叶节点的左右子节点为 nullptr
269   |  54.二叉搜索树的第k大节点  |  对二叉搜索树中序遍历出来的数值正好是递增的
271   |  55.1 二叉树的深度   | 深度是指有几层。如果只有一个节点，深度为 1；如果有左子树，没有柚子树，深度为左子树深度加1；反之则是右子树深度加1；如果既有左子树又有右子树，则取左右子树中深度较大者加1
273   |  55.2 平衡二叉树   | 使用后序遍历来实现，先判断左右子树是不是平衡，同时可以计算当前节点的深度，直到根节点，就知道整棵树是不是平衡的了（叶节点深度为 1，且一定是平衡的）
326   |  68.树中两个节点的最低公共祖先 |

### 位运算

页码 | 题目 |  实现思路
------|-------|-----
100  | 15.二进制中1的个数 | Done
277   | 56.数组中只出现一次的两个数字  |
278   | 56.2.数组中唯一出现一次的数字  |
279   | 总结：元素出现次数的终极总结   |
310   | 65.不用加减乘除做加法    |
312   | 不用新变量交换两个原有变量的值 |

### 查找

页码 | 题目 |  实现思路
------|-------|-----
39    | 3.数组中重复的数    | Done
44    | 4.二维数组中的查找   | Done
82    | 11.旋转数组的最小数字(二分查找)  | Done
263   | 53.数字在排序数组中出现的次数  |
266   |  53.2.0~n-1中缺失的数字 |

### 排序

页码 | 题目 |  实现思路
------|-------|-----
79    | 总结：排序算法    | Done
79    | 总结：数组&链表的快排    | Done
129   | 21.使数组中奇数位于偶数前面  |
205   | 39.数组中出现次过一半的数字   |
209  |  40.最小的k个数   |
214    | 41.数据流中的中位数    |
227   | 45.把数组排列成最小的数   |
249  |  51.数组中的逆序对 |

### 循环和递归

页码 | 题目 |  实现思路
------|-------|-----
74    | 10.斐波那契数列   | Done
110  | 16.数值的整数次方 | Done
114  | 17.打印从1到最大的n位(大数问题) | Done


### 动态规划和贪婪算法

页码 | 题目 |  实现思路
------|-------|-----
96    | 14.剪绳子(动态规划) | Done
218  |  42.连续子数组的最大和    |
231   | 46.把数字翻译成字符串    |
233  |  47.礼物的最大值    |
236   | 48.最长不含重复字符的子字符串  |

### 回溯法

页码 | 题目 |  实现思路
------|-------|-----
89    | 12.矩阵中的路径(回溯法) | Done
92    | 13.机器人的运动范围(回溯法)  |




### 建议
- practice makes perfect
- 建议一次只针对一种题型进行训练，如数组、链表、二叉树、回溯、动态规划
- 有数据结构，算法的基础
- 由易到难
- 总结规律

### 延伸阅读

- 书本配套代码：[https://github.com/zhedahht/CodingInterviewChinese2](https://github.com/zhedahht/CodingInterviewChinese2)
- [剑指offer原书第二版的java实现](https://github.com/ryderchan/point-to-offer-edition2)（整理的很系统）
